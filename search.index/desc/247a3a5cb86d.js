rd_("Ajparameter A, a.k.a., alphaAiBit length of each limbs.nd: sbox degreelParameter S.Aot: state size = rate + capacityBeLog2 of the other CRT modulus is 2^T.A`generator for G1ogenerator of G1CaTODO: remove g, h and beta_h The generator of G1.0A`generator for G2ogenerator of G2BnTODO: remove h and beta_h The generator of G2.AdThe generator of G2.10ClThe constants K0, \xe2\x80\xa6, K_num_wire_types that ensure wire \xe2\x80\xa6CeThe value at the given index, and a proof of validityClReturns true if the trait object wraps an object of type \xe2\x80\xa6ChObtain a variable representing a linear combination. \xe2\x80\xa6CiThe verifying key. It is used by prover to initialize \xe2\x80\xa6ClMulti-linear Extension (MLE) polynomial, this type alias \xe2\x80\xa6BaTrait for Pseudo-random FunctionsBoRescue pseudo-random permutation (PRP) instanceAkStructured reference stringCcA trait for VRF proof, evaluation and verification.CjObtain a variable representing an addition. Return the \xe2\x80\xa6ClElliptic curve related gates and gadgets. Including both \xe2\x80\xa6CfThe number of instances being proved in a batch proof.BkReturn the number of columns of the matrix.CkCompute the multi-scalar-multiplications. Use pippenger \xe2\x80\xa6CkObtain a variable representing a multiplication. Return \xe2\x80\xa6B`Initialize an empty Merkle tree.00AlCreate a new IOP transcript.BlCreate a variable for a Plonk verifying key.AeA new Plonk KZG SNARKAnCreate a new plonk transcript.DeCreate a new plonk transcript. <code>_label</code> is omitted for \xe2\x80\xa6DdCreate a new plonk transcript. <code>label</code> is omitted for \xe2\x80\xa6Amcreate a new plonk transcriptDfCreate a FpElem struct from field element <code>p</code> and split \xe2\x80\xa6BhInitialize a new instance of the sponge.CjCreates a new BLS VRF instance with the given ciphersuite.B`An FpElemVar that represents a 1BiReturn a default variable with value one.AdDefault one variableAbIndex of this leafAkA rescue PRF implementationChRescue pseudorandom permutation for Bls12381 scalars \xe2\x80\xa6AbConstant selector.AeOutput wire selector.ClObtain a variable representing a subtraction. Return the \xe2\x80\xa6CgObtain a variable representing the sum of a list of \xe2\x80\xa6dTagsCnAccessing the i-th vector of the matrix. Function needs to \xe2\x80\xa6oParameter beta.ClA trait for CRHF (based on ark-primitives\xe2\x80\x99 definition, \xe2\x80\xa6oGlorified falseCbDescribes a gate with getter for all selectors \xe2\x80\xa6kA leaf nodeCkThe random seed/key that index a specific function from \xe2\x80\xa6CeCollision-resistant Hash Function (CRHF) based on \xe2\x80\xa6AlA rescue CRHF implementationAoAssociated element of this leafCjCompute the permutation on RescueVector <code>input</code>CdCreates a new sponge with applied domain separation.AoReturns the argument unchanged.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CmReturn an iterator that iterates through all element that \xe2\x80\xa6AgGet the name of a gate.EhOn input a polynomial <code>p</code> and a point <code>point</code>, outputs a proof \xe2\x80\xa600CaInsert a new value at the leftmost available slotBaSelectors for linear combination.BcSign a message with the signing keyCjTrim the universal parameters to specialize the public \xe2\x80\xa600000B`An FpElemVar that represents a 0BjReturn a default variable with value zero.AeDefault zero variablekzero vectorjTree ARITYnparameter A^-1AfCiphersuite IdentifierAaAn empty subtree.jError type0AcSNARK related error11BiAn index type of a leaf in a Merkle tree.AoIndex type for this merkle treeAgInput to the commitmentCbInput to the CRHF, allowed to be dynamically sizedA`Input to the PRFAgThe input of VRF proof.AgPolynomial input domainfProofsBgThe SNARK proof computed by the prover.AdA Plonk SNARK proof.nVRF signature.jFirst typekSecond typeCaPoseidon2 constants for the scalar field of BN254BmPoseidon2 sponge types for BN254 scalar fieldDdCreate a dummy batch proof over <code>n</code> TurboPlonk instances.ClCreate a dummy TurboPlonk verification key for a circuit \xe2\x80\xa6CkReturn vector of the field elements WARNING: may expose \xe2\x80\xa6BaModule for various circuit gates.BbGet the x coordinate of the point.CiGet the variable representing the x coordinate of the \xe2\x80\xa6BbGet the y coordinate of the point.CiGet the variable representing the y coordinate of the \xe2\x80\xa6EeReturns a <code>BoolVar</code> indicating whether <code>a</code> &gt; <code>b</code>.EeReturns a <code>BoolVar</code> indicating whether <code>a</code> &lt; <code>b</code>.CfMerge a type A circuit with a type B circuit. Both \xe2\x80\xa6A`The actual proofAgEvaluation of quotientsDfCompute a SNARK proof of a circuit <code>circuit</code>, using the \xe2\x80\xa6BnCompute a Plonk proof. Refer to Sec 8.4 of \xe2\x80\xa6CgCreates the VRF proof associated with a VRF secret key.0BjThe selector for elliptic curve operation.AmSelectors for multiplication.AaPermutation state00000BaMerkle hash value of this subtreeAnMerkle hash value of this leafBkMerkle hash value of this forgotten subtreeAjAn internal branching nodeAnPublic/encryption key for AEADBdEncryption key for encryption schemeClA field element represented by: p = p.0 + 2^m * p.1. The \xe2\x80\xa6AnAn index to a gate in circuit.AmAn I/O gate for public inputsjMDS matrixBcThe type of output commitment valueAbOutput of the CRHFAaOutput of the PRFAmThe output of VRF evaluation.AoThe # of rounds of rescue hash.CmAn index to the type of gate wires. There are 4 different \xe2\x80\xa6CnAbsorb an input into the sponge. This function will absorb \xe2\x80\xa6Bf\\beta times the above generator of G2.000AgBLS signature based VRFEeCommit algorithm that takes <code>input</code> and blinding randomness <code>r</code>ChGenerate a binding (but not hiding) commitment for a \xe2\x80\xa6BgGenerate a commitment for a polynomial.ChGenerate a commitment for a polynomial Note that the \xe2\x80\xa6BnPerform the final pairing to verify the proof.AgDigest a list of valueskError typesmError module.0CkInsert a list of new values at the leftmost available slotsDeTrim the leaf at position <code>i</code> from memory, if present. \xe2\x80\xa6Chh^randomness: h^t1, h^t2, \xe2\x80\xa6, <strong>h^{t_nv}</strong>0DfA convenience wrapper <code>HasherMerkleTree</code> to instantiate \xe2\x80\xa6BcExpected height of the Merkle tree.BeReturn the height of this merkle tree1EfReturns a <code>BoolVar</code> indicating whether <code>a</code> &gt;= <code>b</code>.EfReturns a <code>BoolVar</code> indicating whether <code>a</code> &lt;= <code>b</code>.AlPolynomial Commitment SchemeCaTrait definition for Pseudorandom function (PRF).BbVerifiable random functions (VRF).ClPerform a linear transform of the vector. Function needs \xe2\x80\xa6BgReturns the leaf value given a positionmUseful macrosAgEvaluation of quotientsAlSelectors for Rescue hashes.BcRemove a leaf at the given positionBdPoseidon2-based Cryptographic SpongeCcThis file contains the APIs wrappers for ark-spongeAoConvert to a list of variables.EeObtain the <code>bit_len</code>-long binary representation of variable <code>a</code>BiUpdate the leaf value at a given positionEdVerify algorithm that output <code>Ok</code> if accepted, or <code>Err</code> if \xe2\x80\xa6CjVerify an element is a leaf of a Merkle tree given the \xe2\x80\xa6DoVerifies that <code>value</code> is the evaluation at <code>x</code> of the \xe2\x80\xa600EeVerify a SNARK proof <code>proof</code> of the circuit <code>circuit</code>, with \xe2\x80\xa6AcVerify a signature.AeVerifies a VRF proof.0AeTag for BLS signatureBlAn index to a witness value of boolean type.BjAn interface for Plonk constraint systems.AlAn element of a Merkle tree.AhMerkle tree element typeAgAn error during IO: {0}CiKeypair for Authenticated Encryption with Associated DataBgKeyPair structure for encryption schemeBdKey for verifying PCS opening proof.AhType for the output sizeBhexternal round constants, state size = 2Bhinternal round constants, state size = 2Bhexternal round constants, state size = 30Bhinternal round constants, state size = 30nGlorified trueClAn elliptic curve point in short Weierstrass affine form \xe2\x80\xa6CnAn elliptic curve point in twisted Edwards affine form (x, \xe2\x80\xa6AbCustomized circuitCkDecrypt a ciphertext with authenticated associated data \xe2\x80\xa6AcDecryption functionDjObtain a variable to the point addition result of <code>point_a</code> \xe2\x80\xa6BdGetter for the public/encryption keyAbGet encryption keyCnEncrypt a message with authenticated associated data which \xe2\x80\xa6AnPublic key encryption functionBaGates and gadgets implementationsClPerform GLV multiplication in circuit (which costs a few \xe2\x80\xa6BfThe inverse point for the edward form.CnObtain a bool variable representing whether input variable \xe2\x80\xa6DgUse <code>crypto_kx</code> to derive shared session secrets and use \xe2\x80\xa6CjTrait definition for Collision-resistant hash function \xe2\x80\xa6AfSample a pair of keys.BnCreates a pair of VRF public and private keys.0CmConstrain a linear combination gate: q1 * a + q2 * b + q3 \xe2\x80\xa6CmModular addition gate: Given Fp elements x, y and modulus \xe2\x80\xa6CkModular multiplication gate: Given Fp elements x, y and \xe2\x80\xa6DjObtain a variable representing <code>q12 * a * b + q34 * c * d</code>, \xe2\x80\xa6AfExpose the m parameter0DdApply Poseidon2 permutation on <code>input</code> and return the \xe2\x80\xa6CjPrelude. Also provides sample instantiations of merkle \xe2\x80\xa6gPreludeBkData structures used in Plonk proof systemsBbGet the witness from the variablesDjReturn the witness value of variable <code>idx</code>. Return error if \xe2\x80\xa6DkA boolean gate, selectors identical to <code>MultiplicationGate</code>, \xe2\x80\xa6CiA circuit instance that consists of the corresponding \xe2\x80\xa6BeElement type for interval merkle treeCnThe index is outside the occupied range in the tree, and a \xe2\x80\xa6BhQueried leaf isn\xe2\x80\x99t in this Merkle treeDeA <code>enum</code> specifying the possible failure modes of the PCS.CeAn error in the underlying polynomial commitment: {0}AbBad parameter: {0}AmInternal node for merkle treeBfAn index to one of the witness values.FbConstrain variable <code>c</code> to the addition of <code>a</code> and <code>b</code>. Return \xe2\x80\xa6BhReturn the maximum allowed number leavesAcAll it\xe2\x80\x99s childrenCkReturns a boxed object from a boxed trait object if the \xe2\x80\xa6CkElliptic curve related gates and gadgets for non-native \xe2\x80\xa6Bfevaluate inputs and return hash outputCnCompute PRF output with a user-provided randomly generated \xe2\x80\xa6gPadding0CjComputes the VRF output given a public input and a VRF \xe2\x80\xa6CnProvides sample instantiations of merkle tree. E.g. Sparse \xe2\x80\xa6CkConvert a base field element to a scalar field element. \xe2\x80\xa6CkConvert a scalar field element to a base field element. \xe2\x80\xa6AkRandomly sample a key pair.CiKey generation algorithm for public key encryption schemeBjCheck whether a BatchProof proves nothing.AmCheck if the matrix is empty.CiObtain a bool variable representing whether two input \xe2\x80\xa6CeA Rust Implementation of the Plonk ZKP System and \xe2\x80\xa6AlJellyfish utilities library.CkObtain a variable representing the result of a logic OR \xe2\x80\xa6FaConstrain variable <code>c</code> to the multiplication of <code>a</code> and <code>b</code>. \xe2\x80\xa6Acnumber of variables0AhThe number of variables.AdKZG PCS opening key.AkUltraPlonk lookup selector.Ci\xe2\x80\x9cRe-insert\xe2\x80\x9d a leaf into the tree using its proof. \xe2\x80\xa6BfThe required SRS size for the circuit.FeConstrain variable <code>c</code> to the subtraction of <code>a</code> and <code>b</code>. Return \xe2\x80\xa6CmTakes as input a struct, and converts them to a series of \xe2\x80\xa60DdReturn a default variable with value <code>true</code> (namely one).CjObtain the truncation of the input. Constrain that the \xe2\x80\xa6kAEAD Error.AbType for the arrayBjThe rate of the sponge used in RescueCRHF.nCommitment keyCnRepresent variable of an Fp element: elem = witness[vars.0]\xe2\x80\xa6AbParameter 1/alpha.Ck<code>B * NUM_LIMBS</code> should equals to <code>T</code>.BmAn internal node value type in a Merkle tree.AlInternal and root node valueBcEnum for each type of Plonk scheme.0BbA Poseidon2 permutation family \xe2\x80\xa6oVRF public key.CiA rescue-based PRF that leverages on Full State Keyed \xe2\x80\xa6oVRF secret key.iSignatureCmAggregate multiple signatures into a single signature The \xe2\x80\xa6CnAn argument system that proves/verifies multiple instances \xe2\x80\xa6CePoseidon2 constants for the scalar field of BLS12-381CaPoseidon2 sponge types for BLS12-381 scalar fieldClSerializers for elements that are Ark-Works serializable \xe2\x80\xa6AeCrate wide constants.BcPoseidon2 Constants copied from \xe2\x80\xa61BnTags to be used for <code>tagged-base64</code>CmAssert the lookup result is Ok. Return a tuple of element \xe2\x80\xa6DfReturn a default variable with value <code>false</code> (namely zero).CbA flag indicating whether the key is a merged key.ChThis module implements Rescue hash function over the \xe2\x80\xa6ClObtain a variable representing the result of a logic AND \xe2\x80\xa6ChObtain a variable representing the result of a logic \xe2\x80\xa6AhModular arithmetic gatesAjThe number of constraints.BbPad the circuit with n dummy gatesAlUtilities for parallel code.Cjgenerate public parameters from RNG. If the RNG is not \xe2\x80\xa60Bdgenerate public parameters from RNG.BmUltraPlonk lookup domain separation selector.Bhopenings of q(x) at 1, omega, \xe2\x80\xa6, and rAfUltraPlonk table keys.lBatch proofsCkAn aggregated SNARK proof that batchly proving multiple \xe2\x80\xa6BjThe ciphertext produced by AEAD encryptionAmPublic encryption cipher textAfMerkle tree commitmentkCommitmentsB`A commitment is an Affine point.Ciround_F: number of external rounds (incl. initial and \xe2\x80\xa6AePolynomial EvaluationAjThe number of input wires.DbNewtype wrapper for hash output that impls <code>NodeValue</code>.Bbround_P: number of internal roundsBbFailed to get array value by index0AiAn UltraPlonk lookup gateAhAn internal Merkle node.CaA standard append only Merkle tree implementationBcA multiplication-then-addition gateDgA <code>enum</code> specifying the possible failure modes of the Plonk.BcPolynomial and its associated typesClThe parameters required by the prover to compute a proof \xe2\x80\xa6ChPreprocessed prover parameters used to compute Plonk \xe2\x80\xa6BfThe type of the hiding/blinding factordCRHFB`Wrapper for rescue hash functionAnThe state size of rescue hash.BdWrapper for the actual hash functionlSigning key.BfAn error in the Plonk SNARK logic: {0}DdA <code>enum</code> specifying the possible failure modes of the \xe2\x80\xa6jTurboPlonk0B`TurboPlonk that supports Plookup0CbPlonk proof verification failed due to wrong proofCmInput a list of polynomials, and a same number of points, \xe2\x80\xa6eInputCkInput a list of polynomials, and the same number of points,AjReturn a merkle commitmentCaImplements a rescue hash based commitment scheme.BcExpose the field element componentsBmExpose the field element variables componentsCbConstrain that <code>a</code> &gt; <code>b</code>.CbConstrain that <code>a</code> &lt; <code>b</code>.BdConvert into a single field element.CmConstruct a new Merkle tree with given height from a data \xe2\x80\xa60BiImplements the ElGamal encryption scheme.BdReturns the maximum supported degreeCjNegate an FpElemVar mod p where p is a public variable \xe2\x80\xa6CjOpen a single polynomial at multiple points. The naive \xe2\x80\xa6CmFast computation of batch opening for a single polynomial \xe2\x80\xa6ClHelper function to compute f(M,x,c) = Mx^a + c. Function \xe2\x80\xa6AlThe number of public inputs.BeThe number of public input variables.BcReturn the current number of leavesCbPlookup verifying key, None if not support lookup.AgPolynomial evaluations.CaCircuit-specific preprocessing to compute the \xe2\x80\xa6CkInput a circuit and the SRS, precompute the proving key \xe2\x80\xa6BbCommitment to q(x):= w(l(x)) whereBiThe range size of UltraPlonk range gates.nUtils for testCcFlatten out the ciphertext into a vector of scalarsAnModule for PolyIOP transcript.CcThis module implements three different types of \xe2\x80\xa6CjImplementing <em>native</em> circuit for rescue transcriptBhImplements ultra-plonk related circuits.nVRF Error: {0}AlTag for BLS verification keyAaDigest error, {0}oInitial vector.AiA linear combination gateAcA gate for logic ORAhTrait for a Merkle proofAoA message is &amp;[MessageUnit]ChThe index is valid but we do not have the leaf in memoryB`A empty gate for circuit paddingCnInstance of a unkeyed cryptographic permutation to be used \xe2\x80\xa6AaProver parametersAbErasure code errorlRescue ErrorAaRescue error typeAiTag for Schnorr signatureCcImplementation of a typical append only merkle treeCjGenerate an aggregated Plonk proof for multiple instances.CfProve satisfiability of multiple instances in a batch.AiDigest an indexed elementCkThe size of the evaluation domain. Should be a power of \xe2\x80\xa6EgReturns an <code>Rc</code>-ed object from an <code>Rc</code>-ed trait object if the \xe2\x80\xa6CaGetter for reference to the public/encryption keyAlGet encryption key referenceCcConstrain that <code>a</code> &gt;= <code>b</code>.CbConstrain that <code>a</code> &lt;= <code>b</code>Bground constants for all external roundsCcBuild a universal merkle tree from a key-value set.BaInsert a general (algebraic) gateBcround constants for internal roundsDkReturn a boolean variable indicating whether variable <code>a</code> is \xe2\x80\xa6BmInterfaces for Plonk-based constraint systemsDaModular addition gate: Given Fp elements &amp;[x] and modulus \xe2\x80\xa6ChReturn the list of variables that simulate the field \xe2\x80\xa6CaReturn all values of siblings of this Merkle path0CcPoseidon2 permutation implementation for spongefishCjApply Poseidon2 permutation on <code>input</code> in placeEg<code>pp_{0}</code>, <code>pp_{1}</code>, \xe2\x80\xa6,pp_{nu_vars} defined by XZZPD19 where \xe2\x80\xa6EfGroup elements of the form <code>{ \\beta^i G }</code>, where <code>i</code> ranges \xe2\x80\xa6fConfigCmpowers of \\beta time the generator g of G1: only used for \xe2\x80\xa6210Bjpowers of \\beta time the generator h of G2Cmpowers of \\beta time the generator h of G2: only used for \xe2\x80\xa610CkThe permutation polynomial commitments. The commitments \xe2\x80\xa6AdExpose 2^m parameter0CkApply an update function <code>f</code> at a given positionD`Wire witness polynomials evaluations at point <code>zeta</code>.CfChange the value of a variable. Only used for testing.A`An addition gateCmBLS VRF scheme. Optimized for signature size, i.e.: PK in \xe2\x80\xa6AdTag for BLS key pairBbAn error in the Plonk circuit: {0}DdA <code>enum</code> specifying the possible failure modes of the \xe2\x80\xa6oA constant gateDjAn equality gate, selectors identical to <code>SubtractionGate</code>, \xe2\x80\xa6BaQueried leaf is already occupied.CkConvenience trait and blanket impl for downstream trait \xe2\x80\xa6AbInvalid Proof: {0}CmThe result of querying at an index in the tree Typically, \xe2\x80\xa6AjFeature not supported: {0}BgA specific Plonk circuit instantiation.AiA Plookup argument proof.AgA deg-2 polynomial gateDfA matrix that consists of <code>STATE_SIZE</code> number of rescue \xe2\x80\xa6CmA rescue hash function consists of a permutation function \xe2\x80\xa6CgData type for rescue prp inputs, keys and internal dataDjUniversal Structured Reference String from <code>universal_setup</code>\xe2\x80\xa6BcUniversal StructuredReferenceStringCiThe parameters required by the verifier to validate a \xe2\x80\xa6CiPreprocessed verifier parameters used to verify Plonk \xe2\x80\xa6CfObtains a variable representing an addition with a \xe2\x80\xa6BbBatch commit a list of polynomialsBcBatch commit a list of polynomials.BoGenerate a commitment for a list of polynomialsEcVerifies that <code>value_i</code> is the evaluation at <code>x_i</code> of the \xe2\x80\xa6EaVerifies that <code>value</code> is the evaluation at <code>x_i</code> of the \xe2\x80\xa61ChBatch verify multiple SNARK proofs (w.r.t. different \xe2\x80\xa6CnReturns a mutable reference to the object within the trait \xe2\x80\xa6CmReturns a reference to the object within the trait object \xe2\x80\xa6ClReturn an <code>EmulatedVariable</code> which equals to a+b.ClReturn an <code>EmulatedVariable</code> which equals to a*b.ClReturn an <code>EmulatedVariable</code> which equals to a-b.CmConstrain a variable to a bool. Return error if the input \xe2\x80\xa6EfAssuming values represented by <code>a</code> is boolean. Constrain <code>a</code> \xe2\x80\xa6CbReconstruct the ciphertext from a list of scalars.ClReturn a pointer to the initial vectors. Does not expose \xe2\x80\xa6AjThe Poseidon2 permutation.B`Module for signature primitives.CmKey scheduling for rescue based PRP for Bls12_381 scalars \xe2\x80\xa6ClA light weight merkle tree is an append only merkle tree \xe2\x80\xa6CjConstrain a mul-addition gate: q_muls[0] * wires[0] *  \xe2\x80\xa6CkObtains a variable representing a multiplication with a \xe2\x80\xa6CgReturn a variable to be the 11th power of the input \xe2\x80\xa6BhInterfaces for Plonk-based proof systemsAaprover parametersB`The list of public input values.CfGenerate a range proof for leaves in [start, end], \xe2\x80\xa6CiA default sanity check on the parameters and constant \xe2\x80\xa6CnWARNING! This trait method is unimplemented and should not \xe2\x80\xa6AdA batching argument.CiRepresent variables of an aggregated SNARK proof that \xe2\x80\xa6Blciphersuite identifier for schnorr signatureAmDivided by zero field elementCfGate for checking a value is the fifth root of anotherAjQueried leaf is forgotten.CkAn IOP transcript consists of a Merlin transcript and a \xe2\x80\xa6CjThe index is too large for the universal public parametersCg\xe2\x80\xbc \xef\xb8\x8fInternal error! Please report to Crypto Team \xe2\x80\xa6AcInvalid Prover: {0}AmInternal node for merkle treeBhinternal diagonal matrix, state size = 2Bhinternal diagonal matrix, state size = 30BaA Plonk instantiated with KZG PCSBbRepresent variable of an EC point.BePoseidon2 Hash (DuplexSponge wrapper)CmSuper-trait specific for univariate polynomial commitment \xe2\x80\xa6BeError from upstream dependencies: {0}AcVerifier parametersAfEnforce self == other.CjConstrain two variables to have the same value. Return \xe2\x80\xa6EfAssuming values represented by <code>a</code> is boolean. Constrain <code>a</code> \xe2\x80\xa6A`Arithmetic gatesCaGenerate a single challenge for the current roundDjGenerate the challenge for the current transcript, <code>_label</code> \xe2\x80\xa6CkHash a sequence of bytes to into a field element, whose \xe2\x80\xa6AhInverse a point variableCdTrait definition for cryptographic commitment schemeChGiven a list of boolean variables, obtain a variable \xe2\x80\xa6EdConstrain that <code>a</code> is true or <code>b</code> is true. Return error if \xe2\x80\xa6BkA simple wrapper of multi-pairing function.DkCreate an FpElemVar from Fp element variable <code>var</code> and split \xe2\x80\xa6ClConstrain a variable to be non-zero. Return error if the \xe2\x80\xa6Dg(Aggregated) proof of evaluations at challenge point <code>zeta</code>.BfThe partial proof for Plookup argumentBhReturn the witness point for the circuitCiConstraint a variable to be the 11th power of another \xe2\x80\xa6CdComputes the VRF output associated with a VRF proof.0BiThe bit length of UltraPlonk range gates.CnWARNING! This trait method is unimplemented and should not \xe2\x80\xa6BfUltraPlonk table domain separation idsDkSimilar to <code>PolynomialCommitmentScheme::trim()</code>, but trim to \xe2\x80\xa6CkTruncation gate. Constrain that b == a modulo 2^bit_length.CmA helper for converting ark_serialize::CanonicalSerialize \xe2\x80\xa6B`A gate for conditional selectionAlMerkle tree is already full.AdParameter error: {0}AgInvalid parameters: {0}0BcBad parameter in function call, {0}0AdPoseidon2 Error typeAkMerkle tree using SHA3 hashCfThis trait holds constants that are used for curve \xe2\x80\xa6AdSignature error typeBmAn interface for SNARKs with universal setup.B`The circuit has wrong Plonk typeBeAppend the message to the transcript.0DhAppend the message to the transcript. <code>_label</code> is omitted for0BmConvert into a single variable with value \xe2\x80\xa6CnReturn the number of variables that one need for an MLE to \xe2\x80\xa6EdReturns a <code>BoolVar</code> indicating whether the variable <code>a</code> is \xe2\x80\xa60CiObtain a bool variable representing whether two point \xe2\x80\xa6BfMerkle Tree traits and implementationsCnReturn a pointer to the mds matrix. Does not expose secret \xe2\x80\xa60DgSame task as <code>PolynomialCommitmentScheme::multi_open()</code>, \xe2\x80\xa6CmThe number of wire types of the circuit. E.g., UltraPlonk \xe2\x80\xa6CkPartially verify a batched proof without performing the \xe2\x80\xa6DkPermutation product polynomial evaluation at point <code>zeta * g</code>\xe2\x80\xa6CeCircuits implementation Circuits for Plonk verifiers.A`Arithmetic gatesCmReturn a pointer to the round key. Does not expose secret \xe2\x80\xa6ClThe selector polynomial commitments. The commitments are \xe2\x80\xa6CkSetup the circuit and the proving key for a (mergeable) \xe2\x80\xa6CgPlookup-related methods. Return true if the circuit \xe2\x80\xa6C`Main module for univariate KZG commitment schemeBbGet verification key by reference.CmAn interface that transforms Plonk circuits to polynomial \xe2\x80\xa6AgTag for BLS signing keyClSize in bytes of a verification key in our BLS signature \xe2\x80\xa6CjSize in bytes of a secret key in our BLS signature scheme.AaBatch commitmentsClciphersuite identifier for BLS signature over BN254 Note \xe2\x80\xa6CnMerkle tree hash function WARN: it\xe2\x80\x99s important to domain \xe2\x80\xa6CiParameters needed for emulating field operations over \xe2\x80\xa6AeInvalid Verifier: {0}BdWrapper for the actual hash functionlMerkle proofAjError type for Merkle treeClA (non)membership Merkle proof consists of all values of \xe2\x80\xa6BgThe number of multiplication selectors.AeParameters error, {0}AhDefines transcript APIs.CiParameters required for a Poseidon2 permutation instance.CaMarker trait for the state of Poseidon2-based \xe2\x80\xa6A`Public ParameterAaPublic parametersCnThis trait defines constants that are used for rescue hash \xe2\x80\xa6B`Tag for Schnorr verification keyBhTrait definition for a signature scheme.AbA subtraction gateBcA trait for Merkle tree index type.AdTranscript error {0}DdA <code>enum</code> specifying the possible failure modes of the \xe2\x80\xa6A`Verification keyBlRepresent variable of a Plonk verifying key.ClChecks if a variable is strictly less than the number of \xe2\x80\xa6BaGet mutable circuit by reference.CjAdd a variable to the circuit; return the index of the \xe2\x80\xa6CjRebuild a merkle tree from a commitment. Return a tree \xe2\x80\xa6EdReturns a <code>BoolVar</code> indicating whether the variable <code>a</code> is \xe2\x80\xa60CaMain module for multilinear KZG commitment schemeBcConstruct a new TurboPlonk circuit.BcConstruct a new UltraPlonk circuit.ClGenerate the universal SRS for the argument system. This \xe2\x80\xa6CaGet the witness in FpElem form from the variablesBmPlonk Circuit that support batch verificationCiThe variable represents an element in the emulated field.BhThe subtree is forgotten from the memoryAkThe {0}-th gate failed: {1}DcMerkle tree generic over <code>Digest</code> hasher <code>H</code>.AmInjected keys for each round.CkBasic functionalities for a merkle tree implementation. \xe2\x80\xa6CnA struct that stores the polynomial evaluations in a Plonk \xe2\x80\xa6ChA standard merkle tree using RATE-3 rescue hash functionBeTranscript with rescue hash function.AhTag for Schnorr key pairCjKZG Polynomial Commitment Scheme on univariate polynomial.ClUnexpected field for elliptic curve operation, currently \xe2\x80\xa6CkVerify an aggregate signature w.r.t. a list of messages \xe2\x80\xa6CkCheck if a list of variables are strictly less than the \xe2\x80\xa6Dccompute the fft size (i.e. <code>num_coeffs</code>) given a degree.DlCreate a <code>BatchProofVar</code> variable from a <code>BatchProof</code>.BhReturn the witness point for the circuitCmCommon gates that should be implemented in any constraint \xe2\x80\xa6DkConstrain a variable to be within the [0, 2^<code>bit_len</code>) range \xe2\x80\xa6ChConstrain a point to be on certain curve, namely its \xe2\x80\xa6CmGet the size of the evaluation domain for arithmetization \xe2\x80\xa6CbAssert the lookup result is NotFound. Return a \xe2\x80\xa6CfGenerate multiple challenges for the current round \xe2\x80\xa6CiCompute the hadamard product of two vectors (of equal \xe2\x80\xa6CkObtain a boolean variable indicating whether a point is \xe2\x80\xa6CnModular addition gate: Given input x: Fp element variable, \xe2\x80\xa6CjModular multiplication gate: Given input x: Fp element \xe2\x80\xa6CgInput a polynomial, and multiple evaluation points, \xe2\x80\xa60CnVerify a multisignature w.r.t. a single message and a list \xe2\x80\xa6CmCreate an FpElemVar from FpElem form field element . This \xe2\x80\xa6CnThe number of range blocks, i.e., the minimal integer such \xe2\x80\xa6CgTrim the leaf at position <code>pos</code> from memory.CeWARN(#495): this method breaks non-membership proofs.BgReturns the leaf value given a positionCkExtended permutation (sigma) polynomials evaluations at \xe2\x80\xa6BeWire witness polynomials commitments.BdSupported Cipher Suites for BLS VRF.Clciphersuite identifier for BLS signature over BLS12_381, \xe2\x80\xa6AnAlgebra over field failed: {0}AgInvalid parameters: {0}AbInvalid parametersAgInvalid Transcript: {0}CfA gate for computing the logic OR value of 2 variablesBcThe circuit does not support lookupCcKZG Polynomial Commitment Scheme on multilinear \xe2\x80\xa6CjPreprocessed prover parameters used to compute Plookup \xe2\x80\xa6AhVerification failed, {0}G`Constrain variable <code>y</code> to the addition of <code>a</code> and <code>c</code>, where <code>c</code> \xe2\x80\xa6DhAppend a single commitment to the transcript. <code>_label</code> is \xe2\x80\xa6BmAppend a single commitment to the transcript.BiAppend a field element to the transcript.ChDefinitions and constructions of plonk constraint systemChConstrain that a+b=c in the emulated field. Checking \xe2\x80\xa6CmConstrain that a*b=c in the emulated field. Checking that \xe2\x80\xa6Cgmerge a set of polynomials. Returns an error if the \xe2\x80\xa6GbConstrain variable <code>y</code> to the product of <code>a</code> and <code>c</code>, where <code>c</code> is \xe2\x80\xa6BhA persistent remove interface, check \xe2\x80\xa6BmA non destructive update interface, check \xe2\x80\xa6AgModule for erasure codeCmSponge hashing based on rescue permutation for RATE 3 and \xe2\x80\xa6CjInverse conversion of the <code>from_emulated_field</code>CiConvert the given index to a vector of branch indices \xe2\x80\xa6BhValue is not on the right elliptic curveCjInterval merkle tree instantiation for interval merkle \xe2\x80\xa6AeIterator out of rangeAeA multiplication gateBfNon membership proof for a given indexChA struct that stores the polynomial evaluations in a \xe2\x80\xa6CdPoseidon parameters for Bls12-381 scalar field, withBfAn error during (de)serialization: {0}0BaAn error during (de)serializationCeTranscript with <code>keccak256</code> hash function.BmA wrapper of <code>merlin::Transcript</code>.CiThe circuit is not finalized before doing arithmetizationA`proof of openingC`Variable index {0} is larger than the bound {1}.C`Append a slice of commitments to the transcript.CaAppend a list of field elements to the transcriptGbObtain a variable that equals <code>x_0</code> if <code>b</code> is zero, or <code>x_1</code> if <code>b</code>\xe2\x80\xa6CkConvert a field element in F(rom) to a field element in \xe2\x80\xa6CjLoad public parameter in production environment. These \xe2\x80\xa60EfVerifies that <code>values</code> are the evaluation at the <code>points</code> of \xe2\x80\xa60BgVerify a single aggregated Plonk proof.CkVerify a range proof for leaves in [start, end], inclusive.AgFailed to create domain0BbValue is not in the right subgroupCnValue is not valid (possible cause: not on curve, in wrong \xe2\x80\xa6B`Merkle tree using keccak256 hash=CkPreprocessed verifier parameters used to verify Plookup \xe2\x80\xa6CdPoseidon parameters for Bls12-381 scalar field, with0CiPublic input length {0} doesn\xe2\x80\x99t match num_inputs = {1}.CnStruct of variables representing a Rescue transcript type, \xe2\x80\xa6AkTag for Schnorr signing keyCaA standard append only Merkle tree implementationEcObtain a variable to the point addition result of <code>p0</code> + <code>p1</code>EaObtain a variable to the point addition result of <code>a</code> + <code>b</code>DkEnforce the variable <code>a</code> to be greater than a given constant \xe2\x80\xa6EhEnforce the variable <code>a</code> to be less than a given constant <code>val</code>\xe2\x80\xa6CnConstrain two point variables to be the same. Return error \xe2\x80\xa6CiConvert an element in the emulated field to a list of \xe2\x80\xa6CfThe polynomial commitment for the wire permutation \xe2\x80\xa6ChRescue pseudorandom permutation for Bls12381 scalars \xe2\x80\xa6BcSet a variable to a public variablekBatch proofB`Adding a variable by a constant.BeKeccak-256 have a 32 byte state size.CnEnum for each type of mergeable circuit. We can only merge \xe2\x80\xa6BdPoseidon2 Permutation for spongefishAmRange proof for a given rangeDkEnforce the variable <code>a</code> to be greater than or equal a given \xe2\x80\xa6DkEnforce the variable <code>a</code> to be less than or equal to a given \xe2\x80\xa6BhAssert the lookup result is NotInMemory.CiExtract the prover parameters from the public parameters.00CiObtain a bool variable representing whether the input \xe2\x80\xa6CoCompute the evaluations in <code>Self::multi_open_rou()</code>.0CeSponge-based CRHF where the Sponge uses Poseidon2 \xe2\x80\xa6ClA rescue-sponge-based CRHF with fixed-input size (if not \xe2\x80\xa6EhA struct that impls <code>DigestAlgorithm</code> for use with <code>MerkleTree</code>\xe2\x80\xa6CaA standard append only Merkle tree implementationCgA sponge over BN254 scalar field, state_size=3, rate=1.CgA sponge over BN254 scalar field, state_size=3, rate=2.Cn<code>UnivariateProverParam</code> is used to generate a proofCeusing blst library and VRF output from SHA256 hashingCeusing blst library and VRF output from SHA512 hashingAkAggregate verification keys0BnAdd a new EC point (as witness) to the circuitCjPublic key encryption function with pre-sampled randomnessDiReturn an <code>EmulatedVariable</code> which equals to a + b where b \xe2\x80\xa6ClReturn an <code>EmulatedVariable</code> which equals to a*b.DiReturn an <code>EmulatedVariable</code> which equals to a - b where b \xe2\x80\xa6CjObtain the fixed-based scalar multiplication result of \xe2\x80\xa6Cjdiffusion (diagonal) matrix minus one used in internal \xe2\x80\xa6CiObtain a bool variable representing whether two input \xe2\x80\xa6CkReturn a pointer to the key injection vectors. Function \xe2\x80\xa6DbCompute the opening proofs in <code>Self::multi_open_rou()</code>.BjVerify an index is not in this merkle treeCfInput vector x and y, and a constant c, generate a \xe2\x80\xa6Cg(Aggregated) proof of evaluation at challenge point \xe2\x80\xa6BfSplit quotient polynomial commitments.BoImplementation of a typical Sparse Merkle Tree.CiSize in bytes of a signature in our BLS signature scheme.BgAttempt to modify the finalized circuitmProver ConfigAiNon-native field overflowAaPermutation keys.CkA sponge over BLS12-381 scalar field, state_size=2, rate=1.CkA sponge over BLS12-381 scalar field, state_size=3, rate=1.CkA sponge over BLS12-381 scalar field, state_size=3, rate=2.CkPublic inputs for partial verification circuit do not matchChExample instantiation of a SparseMerkleTree indexed by IBaThe SNARK does not support lookupChAdd a public input variable; return the index of the \xe2\x80\xa6CkExtract the verifier parameters from the public parameters.00CnReturn the point variable for the infinity point in the TE \xe2\x80\xa6CnCreate an FpElemVar from field element and split parameter \xe2\x80\xa6Cggenerate a non-native circuit for the statement x^5 = yCkCircuit for partially verifying a batched proof without \xe2\x80\xa6BmA persistent update_with interface, check \xe2\x80\xa6CnWARNING! This trait method is unimplemented and should not \xe2\x80\xa6AjBatch non membership proofCiA gate for point addition on x-coordinate between two \xe2\x80\xa6CiA gate for point addition on y-coordinate between two \xe2\x80\xa6CjThe variable represents an SW point in the emulated field.CjThe variable represents an TE point in the emulated field.DeLike <code>HasherMerkleTree</code> except with additional parameters.BcThe number of TurboPlonk selectors.kbatch proofDk<code>UnivariateVerifierParam</code> is used to check evaluation proofs \xe2\x80\xa6CnSuspect: circuit is not satisfied. The quotient polynomial \xe2\x80\xa6CkAppend the verification key and the public input to the \xe2\x80\xa6CiDeterministic, infallible, invertible conversion from \xe2\x80\xa6CkAdd a bool variable to the circuit; return the index of \xe2\x80\xa6Bnmacros to derive instances that implements \xe2\x80\xa6Dgsame as <code>Self::evaluate</code> except that we generate a fresh \xe2\x80\xa6CjMacro for generating a standard merkle tree implementationCi\xe2\x80\x9cRe-insert\xe2\x80\x9d an empty leaf into the tree using its \xe2\x80\xa6Chgenerate a non-native circuit for the statement x^11 = yCmSponge hashing based on rescue permutation for RATE 3. It \xe2\x80\xa6CnA gate for checking a point conforming the twisted Edwards \xe2\x80\xa6Afproof of batch openingoVerifier ConfigCeSponge-based CRHF where the Sponge uses Poseidon2 \xe2\x80\xa6CfA rescue-sponge-based CRHF with variable-input and \xe2\x80\xa6ClAdd a range_check gate that checks whether a variable is \xe2\x80\xa6BlAppend a proof evaluation to the transcript.CmObtain a point variable of the conditional selection from \xe2\x80\xa6CnCompute and return the list of wiring witness polynomials. \xe2\x80\xa6ClAdd a constant variable to the circuit; return the index \xe2\x80\xa6AhAdd an emulated variableFeConstrain variable <code>p2</code> to be the point addition of <code>p0</code> and <code>p1</code>\xe2\x80\xa60CjGenerate the challenge from the current transcript and \xe2\x80\xa6>DiSimilar to <code>RescueCRHF::sponge_with_bit_padding</code> except we \xe2\x80\xa6CmObtain a variable of the result of a variable base scalar \xe2\x80\xa6BhLight weight merkle tree using SHA3 hashBoAPI definitions for structured reference stringDk<code>UniversalParams</code> are the universal parameters for the KZG10 \xe2\x80\xa6ClA universal merkle tree is abstracted as a random-access \xe2\x80\xa6BhDeterministic, infallible inverse of \xe2\x80\xa6AhReturn the witness point0Cithis function helps with slice iterator creation that \xe2\x80\xa6CjTrim the universal parameters to specialize the public \xe2\x80\xa6AdNaive implementation1CnMerkle tree that allows insertion at back. Abstracted as a \xe2\x80\xa6CmSize in bytes of a compressed verification key in our BLS \xe2\x80\xa6CmA mul constant gate. Multiply the first variable with the \xe2\x80\xa6CmMerkle tree that allows forget/remember elements from the \xe2\x80\xa6BaInconsistent Structure error, {0}AcUniversal ParameterCnThis trait defines APIs for polynomial commitment schemes. \xe2\x80\xa6ClState of a sponge over BN254 scalar field, state_size=3, \xe2\x80\xa60CjA point selection gate on x-coordinate for conditional \xe2\x80\xa6CjA point selection gate on y-coordinate for conditional \xe2\x80\xa6CaMerkle tree that supports generating range proofsDhA struct that can be serialized into <code>Vec</code> of field elements.C`Append the plookup evaluation to the transcript.CmConstrain that a+b=c in the emulated field. This function \xe2\x80\xa6CmConstrain that a*b=c in the emulated field for a constant \xe2\x80\xa6CkConstrain two emulated variables to be the same. Return \xe2\x80\xa6CiObtain a bool variable representing whether two input \xe2\x80\xa60CnCompute the multi-scalar-multiplications where each scalar \xe2\x80\xa6EhGiven <code>degree</code> of the committed polynomial and <code>num_points</code> to \xe2\x80\xa6CgRescue-based Commitment instance for fixed-length inputCbState of a sponge over BLS12-381 scalar field, \xe2\x80\xa600CiA standard light merkle tree using RATE-3 rescue hash \xe2\x80\xa6BeAppend the message to the transcript.CmCompute and return the combined lookup table vector given \xe2\x80\xa6ClObtain an emulated variable of the conditional selection \xe2\x80\xa6DcDecode into <code>data_size</code> data elements via polynomial \xe2\x80\xa6EcErasure-encode <code>data</code> into <code>data.len() + parity_size</code> shares.CdCheck circuit satisfiability against a public input.CkCompute and return the polynomial that interpolates the \xe2\x80\xa6CmCompute and return the public input polynomial. Return an \xe2\x80\xa61ClCompute and return selector polynomials. Return an error \xe2\x80\xa6CcAdd a new EC point (as public input) to the circuitCiFinalize the setup of the circuit before arithmetization.CdSerialize into a <code>Vec</code> of field elements.CnTrait for aggregatable signatures. TODO: generic over hash \xe2\x80\xa6DgCompute constants K0, K1, \xe2\x80\xa6, K_{<code>num_wire_types</code>-1} so \xe2\x80\xa6CjGenerate the challenge from the current transcript and \xe2\x80\xa6DaSqueeze <code>num_elements</code> field elements from the sponge.BmLight weight merkle tree using Keccak256 hashCiCompute and return the product polynomial for Plookup \xe2\x80\xa6ChPlookup-related methods Return default errors if the \xe2\x80\xa6CaAdd a new EC point (as a constant) to the circuitCiAdd a public bool variable to the circuit; return the \xe2\x80\xa6CkFinalize the setup of a mergeable circuit. Two circuits \xe2\x80\xa6CiMacros for implementing ToTreversalPath for BigUint types0AnAdd a public emulated variableCjConstrain two emulated point variables to be the same. \xe2\x80\xa60DiLike <code>reed_solomon_erasure_decode</code> except input points are \xe2\x80\xa6CmObtain a variable of the result of a variable base scalar \xe2\x80\xa6CdCompute the multi-scalar-multiplications in circuit.CkCompute and return the polynomial that interpolates the \xe2\x80\xa6CfSize in bytes of a compressed signature in our BLS \xe2\x80\xa6ChConvert the group elements to a list of scalars that \xe2\x80\xa6B`Add a constant emulated variableBhAdd a new emulated EC point (as witness)0ChCreate a table with keys/values [0, \xe2\x80\xa6, n - 1] and [\xe2\x80\xa6CkMacros for implementing ToTreversalPath for primitive types0CnWARNING! This trait method is unimplemented and should not \xe2\x80\xa6DjCreate <code>num_instances</code> type A/B instance verifying keys and \xe2\x80\xa6CaMacro for generating a forgetable merkle tree \xe2\x80\xa6CnUniversal Merkle tree that allows forget/remember elements \xe2\x80\xa6CgA universal merkle tree that allows non destructive \xe2\x80\xa6CmCompute and return the product polynomial for permutation \xe2\x80\xa6CcMacro for generating the range proof implementationChObtain an emulated point variable of the conditional \xe2\x80\xa60CkCompute the sorted concatenation of the (merged) lookup \xe2\x80\xa6Cltwo circuit with the same statement should have the same \xe2\x80\xa6ChCompute and return extended permutation polynomials. \xe2\x80\xa6BbAdd a new public emulated EC point0;BdAdd a new constant emulated EC point0")