searchState.loadedDescShard("jf_relation", 0, "Interfaces for Plonk-based constraint systems\nA <code>enum</code> specifying the possible failure modes of the …\nFailed to create domain\nAlgebra over field failed: {0}\nThe {0}-th gate failed: {1}\nFailed to get array value by index\n‼ ️Internal error! Please report to Crypto Team …\nThe circuit does not support lookup\nAttempt to modify the finalized circuit\nFeature not supported: {0}\nInvalid parameters: {0}\nPublic input length {0} doesn’t match num_inputs = {1}.\nThe circuit is not finalized before doing arithmetization\nUnexpected field for elliptic curve operation, currently …\nVariable index {0} is larger than the bound {1}.\nThe circuit has wrong Plonk type\nCrate wide constants.\nDefinitions and constructions of plonk constraint system\nReturns the argument unchanged.\nGates and gadgets implementations\nModule for various circuit gates.\nCalls <code>U::from(self)</code>.\nThe number of input wires.\nThe number of multiplication selectors.\nThe number of TurboPlonk selectors.\nCompute constants K0, K1, …, K_{<code>num_wire_types</code>-1} so …\nAn interface that transforms Plonk circuits to polynomial …\nAn index to a witness value of boolean type.\nAn interface for Plonk constraint systems.\nAn index to a gate in circuit.\nEnum for each type of mergeable circuit. We can only merge …\nA specific Plonk circuit instantiation.\nEnum for each type of Plonk scheme.\nTurboPlonk\nFirst type\nSecond type\nTurboPlonk that supports Plookup\nAn index to one of the witness values.\nAn index to the type of gate wires. There are 4 different …\nObtain a variable representing an addition. Return the …\nObtains a variable representing an addition with a …\nConstrain variable <code>y</code> to the addition of <code>a</code> and <code>c</code>, where <code>c</code> …\nConstrain variable <code>c</code> to the addition of <code>a</code> and <code>b</code>. Return …\nAdd a range_check gate that checks whether a variable is …\nObtain an emulated point variable of the conditional …\nObtain an emulated point variable of the conditional …\nObtain a point variable of the conditional selection from …\nCheck circuit satisfiability against a public input.\nChecks if a variable is strictly less than the number of …\nCheck if a list of variables are strictly less than the …\nCompute and return extended permutation polynomials. …\nCompute and return the polynomial that interpolates the …\nCompute and return the product polynomial for Plookup …\nCompute the sorted concatenation of the (merged) lookup …\nCompute and return the combined lookup table vector given …\nCompute and return the product polynomial for permutation …\nCompute and return the public input polynomial. Return an …\nCompute and return the polynomial that interpolates the …\nPlookup-related methods Return default errors if the …\nCompute and return selector polynomials. Return an error …\nCompute and return the polynomial that interpolates the …\nCompute and return the list of wiring witness polynomials. …\nObtain a variable that equals <code>x_0</code> if <code>b</code> is zero, or <code>x_1</code> if <code>b</code>…\nObtain an emulated variable of the conditional selection …\nAdd a bool variable to the circuit; return the index of …\nAdd a new constant emulated EC point\nAdd a new constant emulated EC point\nAdd a constant emulated variable\nAdd a new EC point (as a constant) to the circuit\nAdd a constant variable to the circuit; return the index …\nAdd a new emulated EC point (as witness)\nAdd a new emulated EC point (as witness)\nAdd an emulated variable\nAdd a new EC point (as witness) to the circuit\nAdd a public bool variable to the circuit; return the …\nAdd a new public emulated EC point\nAdd a new public emulated EC point\nAdd a public emulated variable\nAdd a new EC point (as public input) to the circuit\nAdd a public input variable; return the index of the …\nCreate a table with keys/values [0, …, n - 1] and […\nAdd a variable to the circuit; return the index of the …\nObtain a variable to the point addition result of <code>point_a</code> …\nReturn an <code>EmulatedVariable</code> which equals to a+b.\nReturn an <code>EmulatedVariable</code> which equals to a + b where b …\nConstrain that a+b=c in the emulated field. This function …\nConstrain that a+b=c in the emulated field. Checking …\nReturn an <code>EmulatedVariable</code> which equals to a*b.\nReturn an <code>EmulatedVariable</code> which equals to a*b.\nConstrain that a*b=c in the emulated field for a constant …\nConstrain that a*b=c in the emulated field. Checking that …\nReturn an <code>EmulatedVariable</code> which equals to a-b.\nReturn an <code>EmulatedVariable</code> which equals to a - b where b …\nObtain a variable to the point addition result of <code>p0</code> + <code>p1</code>\nConstrain variable <code>p2</code> to be the point addition of <code>p0</code> and <code>p1</code>…\nReturn the witness point\nObtain a variable to the point addition result of <code>a</code> + <code>b</code>\nConstrain variable <code>p2</code> to be the point addition of <code>p0</code> and <code>p1</code>…\nReturn the witness point\nReturn the witness point for the circuit\nConstrain a variable to a bool. Return error if the input …\nCommon gates that should be implemented in any constraint …\nConstrain two emulated point variables to be the same. …\nConstrain two emulated point variables to be the same. …\nConstrain two emulated variables to be the same. Return …\nConstrain two variables to have the same value. Return …\nAssuming values represented by <code>a</code> is boolean. Constrain <code>a</code> …\nConstrain that <code>a</code> &gt;= <code>b</code>.\nEnforce the variable <code>a</code> to be greater than or equal a given …\nConstrain that <code>a</code> &gt; <code>b</code>.\nEnforce the variable <code>a</code> to be greater than a given constant …\nConstrain a variable to be within the [0, 2^<code>bit_len</code>) range …\nConstrain that <code>a</code> &lt;= <code>b</code>\nEnforce the variable <code>a</code> to be less than or equal to a given …\nConstrain that <code>a</code> &lt; <code>b</code>.\nEnforce the variable <code>a</code> to be less than a given constant <code>val</code>…\nConstrain a point to be on certain curve, namely its …\nConstrain two point variables to be the same. Return error …\nAssuming values represented by <code>a</code> is boolean. Constrain <code>a</code> …\nGet the size of the evaluation domain for arithmetization …\nReturn a default variable with value <code>false</code> (namely zero).\nFinalize the setup of the circuit before arithmetization.\nFinalize the setup of a mergeable circuit. Two circuits …\nObtain the fixed-based scalar multiplication result of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nArithmetic gates\nPerform GLV multiplication in circuit (which costs a few …\nInsert a general (algebraic) gate\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInverse a point variable\nObtain a bool variable representing whether two input …\nObtain a bool variable representing whether two input …\nObtain a bool variable representing whether two input …\nObtain a bool variable representing whether the input …\nObtain a bool variable representing whether two input …\nReturns a <code>BoolVar</code> indicating whether <code>a</code> &gt;= <code>b</code>.\nReturns a <code>BoolVar</code> indicating whether the variable <code>a</code> is …\nReturns a <code>BoolVar</code> indicating whether <code>a</code> &gt; <code>b</code>.\nReturns a <code>BoolVar</code> indicating whether the variable <code>a</code> is …\nReturn a boolean variable indicating whether variable <code>a</code> is …\nReturns a <code>BoolVar</code> indicating whether <code>a</code> &lt;= <code>b</code>.\nReturns a <code>BoolVar</code> indicating whether the variable <code>a</code> is …\nReturns a <code>BoolVar</code> indicating whether <code>a</code> &lt; <code>b</code>.\nReturns a <code>BoolVar</code> indicating whether the variable <code>a</code> is …\nObtain a boolean variable indicating whether a point is …\nObtain a bool variable representing whether two point …\nObtain a bool variable representing whether input variable …\nObtain a variable representing a linear combination. …\nConstrain a linear combination gate: q1 * a + q2 * b + q3 …\nObtain a variable representing the result of a logic AND …\nGiven a list of boolean variables, obtain a variable …\nObtain a variable representing the result of a logic …\nObtain a variable representing the result of a logic OR …\nConstrain that <code>a</code> is true or <code>b</code> is true. Return error if …\nMerge a type A circuit with a type B circuit. Both …\nModular addition gate: Given Fp elements x, y and modulus …\nModular addition gate: Given input x: Fp element variable, …\nModular addition gate: Given Fp elements &amp;[x] and modulus …\nModular multiplication gate: Given Fp elements x, y and …\nModular multiplication gate: Given input x: Fp element …\nNegate an FpElemVar mod p where p is a public variable …\nObtain a variable representing a multiplication. Return …\nObtain a variable representing <code>q12 * a * b + q34 * c * d</code>, …\nConstrain a mul-addition gate: q_muls[0] * wires[0] *  …\nObtains a variable representing a multiplication with a …\nConstrain variable <code>y</code> to the product of <code>a</code> and <code>c</code>, where <code>c</code> is …\nConstrain variable <code>c</code> to the multiplication of <code>a</code> and <code>b</code>. …\nReturn the point variable for the infinity point in the TE …\nConstruct a new TurboPlonk circuit.\nConstruct a new UltraPlonk circuit.\nInput vector x and y, and a constant c, generate a …\ngenerate a non-native circuit for the statement x^11 = y\ngenerate a non-native circuit for the statement x^11 = y\ngenerate a non-native circuit for the statement x^5 = y\nConstrain a variable to be non-zero. Return error if the …\nThe number of constraints.\nThe number of public input variables.\nThe number of range blocks, i.e., the minimal integer such …\nThe number of variables.\nThe number of wire types of the circuit. E.g., UltraPlonk …\nReturn a default variable with value one.\nDefault one variable\nPad the circuit with n dummy gates\nReturn the witness point for the circuit\nConstraint a variable to be the 11th power of another …\nReturn a variable to be the 11th power of the input …\nThe list of public input values.\nArithmetic gates\nThe bit length of UltraPlonk range gates.\nThe range size of UltraPlonk range gates.\nSet a variable to a public variable\nThe required SRS size for the circuit.\nObtain a variable representing a subtraction. Return the …\nConstrain variable <code>c</code> to the subtraction of <code>a</code> and <code>b</code>. Return …\nObtain a variable representing the sum of a list of …\nPlookup-related methods. Return true if the circuit …\nReturn a default variable with value <code>true</code> (namely one).\nObtain the truncation of the input. Constrain that the …\nTruncation gate. Constrain that b == a modulo 2^bit_length.\nObtain the <code>bit_len</code>-long binary representation of variable <code>a</code>\nObtain a variable of the result of a variable base scalar …\nObtain a variable of the result of a variable base scalar …\nReturn the witness value of variable <code>idx</code>. Return error if …\nChange the value of a variable. Only used for testing.\nReturn a default variable with value zero.\nDefault zero variable\nBit length of each limbs.\nThe variable represents an element in the emulated field.\nParameters needed for emulating field operations over …\n<code>B * NUM_LIMBS</code> should equals to <code>T</code>.\nA struct that can be serialized into <code>Vec</code> of field elements.\nLog2 of the other CRT modulus is 2^T.\nElliptic curve related gates and gadgets. Including both …\nReturns the argument unchanged.\nConvert an element in the emulated field to a list of …\nCalls <code>U::from(self)</code>.\nReturn the list of variables that simulate the field …\nSerialize into a <code>Vec</code> of field elements.\nUtils for test\nInverse conversion of the <code>from_emulated_field</code>\nImplements ultra-plonk related circuits.\nParameter beta.\nCompute the multi-scalar-multiplications in circuit.\nParameter 1/alpha.\nRepresent variable of an EC point.\nParameter S.\nThis trait holds constants that are used for curve …\nAn elliptic curve point in twisted Edwards affine form (x, …\nElliptic curve related gates and gadgets for non-native …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the x coordinate of the point.\nGet the variable representing the x coordinate of the …\nGet the y coordinate of the point.\nGet the variable representing the y coordinate of the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe inverse point for the edward form.\nCompute the multi-scalar-multiplications. Use pippenger …\nCompute the multi-scalar-multiplications where each scalar …\nThe variable represents an SW point in the emulated field.\nThe variable represents an TE point in the emulated field.\nAn elliptic curve point in short Weierstrass affine form …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ntwo circuit with the same statement should have the same …\nModular arithmetic gates\nA field element represented by: p = p.0 + 2^m * p.1. The …\nRepresent variable of an Fp element: elem = witness[vars.0]…\nExpose the field element components\nExpose the field element variables components\nConvert into a single variable with value …\nEnforce self == other.\nConvert into a single field element.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a FpElem struct from field element <code>p</code> and split …\nCreate an FpElemVar from field element and split parameter …\nCreate an FpElemVar from FpElem form field element . This …\nCreate an FpElemVar from Fp element variable <code>var</code> and split …\nAn FpElemVar that represents a 1\nExpose the m parameter\nExpose the m parameter\nExpose 2^m parameter\nExpose 2^m parameter\nGet the witness from the variables\nGet the witness in FpElem form from the variables\nAn FpElemVar that represents a 0\nAn addition gate\nA boolean gate, selectors identical to <code>MultiplicationGate</code>, …\nA gate for conditional selection\nAdding a variable by a constant.\nA constant gate\nA mul constant gate. Multiply the first variable with the …\nA gate for point addition on x-coordinate between two …\nA gate for point addition on y-coordinate between two …\nA gate for checking a point conforming the twisted Edwards …\nAn equality gate, selectors identical to <code>SubtractionGate</code>, …\nGate for checking a value is the fifth root of another\nDescribes a gate with getter for all selectors …\nAn I/O gate for public inputs\nA linear combination gate\nA gate for logic OR\nA gate for computing the logic OR value of 2 variables\nAn UltraPlonk lookup gate\nA multiplication-then-addition gate\nA multiplication gate\nA empty gate for circuit padding\nA deg-2 polynomial gate\nA point selection gate on x-coordinate for conditional …\nA point selection gate on y-coordinate for conditional …\nA subtraction gate\nReturns a boxed object from a boxed trait object if the …\nReturns a mutable reference to the object within the trait …\nReturns an <code>Rc</code>-ed object from an <code>Rc</code>-ed trait object if the …\nReturns a reference to the object within the trait object …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the trait object wraps an object of type …\nGet the name of a gate.\nConstant selector.\nUltraPlonk lookup domain separation selector.\nThe selector for elliptic curve operation.\nSelectors for Rescue hashes.\nSelectors for linear combination.\nUltraPlonk lookup selector.\nSelectors for multiplication.\nOutput wire selector.\nUltraPlonk table domain separation ids\nUltraPlonk table keys.")