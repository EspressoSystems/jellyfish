searchState.loadedDescShard("jf_pcs", 0, "Polynomial Commitment Scheme\nBatch commitments\nBatch proofs\nCommitments\nPolynomial Evaluation\nPolynomial input domain\nPolynomial and its associated types\nThis trait defines APIs for polynomial commitment schemes. …\nProofs\nProver parameters\nStructured reference string\nAPI definitions for structured reference string\nSuper-trait specific for univariate polynomial commitment …\nVerifier parameters\nBatch commit a list of polynomials\nInput a list of polynomials, and a same number of points, …\nVerifies that <code>value_i</code> is the evaluation at <code>x_i</code> of the …\ncompute the fft size (i.e. <code>num_coeffs</code>) given a degree.\nGenerate a binding (but not hiding) commitment for a …\nError module.\nExtract the prover parameters from the public parameters.\nExtract the verifier parameters from the public parameters.\nLoad public parameter in production environment. These …\nLoad public parameter in production environment. These …\nOpen a single polynomial at multiple points. The naive …\nSame task as <code>PolynomialCommitmentScheme::multi_open()</code>, …\nGiven <code>degree</code> of the committed polynomial and <code>num_points</code> to …\nCompute the evaluations in <code>Self::multi_open_rou()</code>.\nCompute the opening proofs in <code>Self::multi_open_rou()</code>.\nInput a polynomial, and multiple evaluation points, …\nVerifies that <code>values</code> are the evaluation at the <code>points</code> of …\nMain module for multilinear KZG commitment scheme\nOn input a polynomial <code>p</code> and a point <code>point</code>, outputs a proof …\nPrelude\nModule for PolyIOP transcript.\nTrim the universal parameters to specialize the public …\nTrim the universal parameters to specialize the public …\nSimilar to <code>PolynomialCommitmentScheme::trim()</code>, but trim to …\nTrim the universal parameters to specialize the public …\nMain module for univariate KZG commitment scheme\nVerifies that <code>value</code> is the evaluation at <code>x</code> of the …\nInvalid parameters: {0}\nInvalid Proof: {0}\nInvalid Prover: {0}\nInvalid Verifier: {0}\nA <code>enum</code> specifying the possible failure modes of the PCS.\nAn error during (de)serialization: {0}\nTranscript error {0}\nError from upstream dependencies: {0}\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMulti-linear Extension (MLE) polynomial, this type alias …\nproof of batch opening\nKZG Polynomial Commitment Scheme on multilinear …\nproof of opening\nBatch commit a list of polynomials.\nInput\nVerifies that <code>value</code> is the evaluation at <code>x_i</code> of the …\nGenerate a commitment for a polynomial.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOn input a polynomial <code>p</code> and a point <code>point</code>, outputs a proof …\nThe actual proof\nEvaluation of quotients\nCommitment to q(x):= w(l(x)) where\nopenings of q(x) at 1, omega, …, and r\nTrim the universal parameters to specialize the public …\nVerifies that <code>value</code> is the evaluation at <code>x</code> of the …\nA commitment is an Affine point.\nProver Config\nUniversal Parameter\nVerifier Config\n<code>UnivariateProverParam</code> is used to generate a proof\n<code>UniversalParams</code> are the universal parameters for the KZG10 …\n<code>UnivariateVerifierParam</code> is used to check evaluation proofs …\n\\beta times the above generator of G2.\n\\beta times the above generator of G2.\nExtract the prover parameters from the public parameters.\nExtract the prover parameters from the public parameters.\nExtract the verifier parameters from the public parameters.\nExtract the verifier parameters from the public parameters.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ngenerator for G1\ngenerator of G1\nTODO: remove g, h and beta_h The generator of G1.\nReturn the number of variables that one need for an MLE to …\ngenerator for G2\ngenerator of G2\nTODO: remove h and beta_h The generator of G2.\nThe generator of G2.\nh^randomness: h^t1, h^t2, …, <strong>h^{t_nv}</strong>\nh^randomness: h^t1, h^t2, …, <strong>h^{t_nv}</strong>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the maximum supported degree\nmerge a set of polynomials. Returns an error if the …\nnumber of variables\nnumber of variables\n<code>pp_{0}</code>, <code>pp_{1}</code>, …,pp_{nu_vars} defined by XZZPD19 where …\nGroup elements of the form <code>{ \\beta^i G }</code>, where <code>i</code> ranges …\nConfig\npowers of \\beta time the generator g of G1: only used for …\npowers of \\beta time the generator h of G2\npowers of \\beta time the generator h of G2: only used for …\nprover parameters\nTrim the universal parameters to specialize the public …\nTrim the universal parameters to specialize the public …\nNaive implementation\nTrim the universal parameters to specialize the public …\nAn IOP transcript consists of a Merlin transcript and a …\nInvalid Transcript: {0}\nAn error during (de)serialization: {0}\nA <code>enum</code> specifying the possible failure modes of the …\nAppend the message to the transcript.\nAppend the message to the transcript.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate the challenge from the current transcript and …\nGenerate the challenge from the current transcript and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new IOP transcript.\nbatch proof\nKZG Polynomial Commitment Scheme on univariate polynomial.\nproof of opening\nGenerate a commitment for a list of polynomials\nInput a list of polynomials, and the same number of points,\nVerifies that <code>value_i</code> is the evaluation at <code>x_i</code> of the …\nGenerate a commitment for a polynomial Note that the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFast computation of batch opening for a single polynomial …\nCompute the evaluations in <code>Self::multi_open_rou()</code>.\nInput a polynomial, and multiple evaluation points, …\nVerifies that <code>values</code> are the evaluation at the <code>points</code> of …\nOn input a polynomial <code>p</code> and a point <code>point</code>, outputs a proof …\nEvaluation of quotients\nTrim the universal parameters to specialize the public …\nVerifies that <code>value</code> is the evaluation at <code>x</code> of the …")