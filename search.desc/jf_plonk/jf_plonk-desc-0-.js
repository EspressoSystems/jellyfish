searchState.loadedDescShard("jf_plonk", 0, "A Rust Implementation of the Plonk ZKP System and …\nEnum for each type of Plonk scheme.\nTurboPlonk\nTurboPlonk that supports Plookup\nCustomized circuit\nCrate wide constants.\nError module.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInterfaces for Plonk-based proof systems\nThis module implements three different types of …\nCircuits implementation Circuits for Plonk verifiers.\nImplementing <em>native</em> circuit for rescue transcript\nRepresent variables of an aggregated SNARK proof that …\nPlonk Circuit that support batch verification\nRepresent variable of a Plonk verifying key.\nAggregate verification keys\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a variable for a Plonk verifying key.\nCircuit for partially verifying a batched proof without …\nConvert to a list of variables.\nStruct of variables representing a Rescue transcript type, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nKeccak-256 have a 32 byte state size.\nAn error in the Plonk circuit: {0}\nDivided by zero field element\nFailed to create domain\nFailed to get array value by index\nThe index is too large for the universal public parameters\nInvalid parameters\nAn error during IO: {0}\nIterator out of range\nNon-native field overflow\nAn error in the underlying polynomial commitment: {0}\nInvalid parameters: {0}\nA <code>enum</code> specifying the possible failure modes of the Plonk.\nPublic inputs for partial verification circuit do not match\nRescue Error\nAn error during (de)serialization\nA <code>enum</code> specifying the possible failure modes of the …\nAn error in the Plonk SNARK logic: {0}\nThe SNARK does not support lookup\nPlonk proof verification failed due to wrong proof\nSuspect: circuit is not satisfied. The quotient polynomial …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSNARK related error\nA Plonk instantiated with KZG PCS\nThe SNARK proof computed by the prover.\nThe parameters required by the prover to compute a proof …\nAn interface for SNARKs with universal setup.\nUniversal Structured Reference String from <code>universal_setup</code>…\nThe parameters required by the verifier to validate a …\nAn argument system that proves/verifies multiple instances …\nGenerate an aggregated Plonk proof for multiple instances.\nBatch verify multiple SNARK proofs (w.r.t. different …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA new Plonk KZG SNARK\nCircuit-specific preprocessing to compute the …\nInput a circuit and the SRS, precompute the proving key …\nCompute a SNARK proof of a circuit <code>circuit</code>, using the …\nCompute a Plonk proof. Refer to Sec 8.4 of …\nData structures used in Plonk proof systems\nGenerate the universal SRS for the argument system. This …\nVerify a SNARK proof <code>proof</code> of the circuit <code>circuit</code>, with …\nVerify a single aggregated Plonk proof.\nA batching argument.\nA circuit instance that consists of the corresponding …\nAggregate verification keys\nProve satisfiability of multiple instances in a batch.\nCreate <code>num_instances</code> type A/B instance verifying keys and …\nGet mutable circuit by reference.\nPerform the final pairing to verify the proof.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPartially verify a batched proof without performing the …\nSetup the circuit and the proving key for a (mergeable) …\nGet verification key by reference.\nAn aggregated SNARK proof that batchly proving multiple …\nCommitment key\nKey for verifying PCS opening proof.\nA struct that stores the polynomial evaluations in a …\nA Plookup argument proof.\nPreprocessed prover parameters used to compute Plookup …\nPreprocessed verifier parameters used to verify Plookup …\nA Plonk SNARK proof.\nA struct that stores the polynomial evaluations in a Plonk …\nPreprocessed prover parameters used to compute Plonk …\nUniversal StructuredReferenceString\nPreprocessed verifier parameters used to verify Plonk …\n\\beta times the above generator of G2.\n\\beta times the above generator of G2.\nConvert the group elements to a list of scalars that …\nCreate a <code>BatchProofVar</code> variable from a <code>BatchProof</code>.\nThe size of the evaluation domain. Should be a power of …\nCreate a dummy batch proof over <code>n</code> TurboPlonk instances.\nCreate a dummy TurboPlonk verification key for a circuit …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTODO: remove g, h and beta_h The generator of G1.\nTODO: remove h and beta_h The generator of G2.\nThe generator of G2.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck whether a BatchProof proves nothing.\nA flag indicating whether the key is a merged key.\nThe constants K0, …, K_num_wire_types that ensure wire …\nThe number of instances being proved in a batch proof.\nThe number of public inputs.\nKZG PCS opening key.\n(Aggregated) proof of evaluations at challenge point <code>zeta</code>.\nPermutation product polynomial evaluation at point <code>zeta * g</code>…\nThe partial proof for Plookup argument\nPlookup verifying key, None if not support lookup.\nPolynomial evaluations.\nGroup elements of the form <code>{ \\beta^i G }</code>, where <code>i</code> ranges …\nConfig\npowers of \\beta time the generator g of G1: only used for …\npowers of \\beta time the generator h of G2\npowers of \\beta time the generator h of G2: only used for …\nThe polynomial commitment for the wire permutation …\nThe selector polynomial commitments. The commitments are …\n(Aggregated) proof of evaluation at challenge point …\nThe permutation polynomial commitments. The commitments …\nSplit quotient polynomial commitments.\nThe verifying key. It is used by prover to initialize …\nExtended permutation (sigma) polynomials evaluations at …\nWire witness polynomials evaluations at point <code>zeta</code>.\nWire witness polynomials commitments.\nDefines transcript APIs.\nTranscript with rescue hash function.\nTranscript with <code>keccak256</code> hash function.\nA wrapper of <code>merlin::Transcript</code>.\nAppend a challenge to the transcript. <code>_label</code> is omitted for\nAppend a challenge to the transcript.\nAppend a single commitment to the transcript. <code>_label</code> is …\nAppend a single commitment to the transcript.\nAppend a slice of commitments to the transcript.\nAppend the message to the transcript.\nAppend the message to the transcript. <code>_label</code> is omitted for\nAppend the message to the transcript. <code>_label</code> is omitted for\nAppend the plookup evaluation to the transcript.\nAppend a proof evaluation to the transcript.\nAppend the verification key and the public input to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate the challenge for the current transcript, and …\nGenerate the challenge for the current transcript, and …\nGenerate the challenge for the current transcript, and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new plonk transcript.\nCreate a new plonk transcript. <code>_label</code> is omitted for …\nCreate a new plonk transcript. <code>label</code> is omitted for …\ncreate a new plonk transcript")